<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Valentine?</title>
  <style>
    body{
      margin:0;
      font-family: Arial, Helvetica, sans-serif;
      min-height:100vh;
      display:grid;
      place-items:center;
      background: radial-gradient(circle at top, #ffe5ec, #fff);
      overflow:hidden;
    }

    /* White box (kept the earlier size) */
    .card{
      width:min(520px, 92vw);
      padding:28px 26px;
      border-radius:18px;
      background: rgba(255,255,255,0.88);
      backdrop-filter: blur(8px);
      box-shadow: 0 18px 50px rgba(0,0,0,0.12);
      text-align:center;
      position:relative;
    }

    h1{
      margin:0 0 18px;
      font-size:28px;
      letter-spacing:.2px;
      color:#b1004b;
    }

    /* Buttons row (YES stays in the white box) */
    .buttonsRow{
      display:flex;
      justify-content:center;
      gap:14px;
      margin-top:10px;
    }

    button{
      border:0;
      padding:12px 20px;
      border-radius:999px;
      font-size:16px;
      cursor:pointer;
      user-select:none;
      transition: transform 160ms ease;
    }
    button:active{ transform: scale(0.98); }

    #yesBtn{
      background:#ff2d6d;
      color:#fff;
      box-shadow:0 10px 20px rgba(255,45,109,0.25);
      transform: scale(1);
      transition: transform 520ms cubic-bezier(.2,.8,.2,1);
      will-change: transform;
      position: relative;
      z-index: 2;
    }

    /* NO is moved with transform while positioned fixed */
    #noBtn{
      background:#2b2b2b;
      color:#fff;
      position: fixed;
      left: 0;
      top: 0;
      transform: translate(-9999px, -9999px);
      transition: transform 800ms cubic-bezier(.16,1,.3,1); /* buttery + faster */
      will-change: transform;
      z-index: 3;
    }

    /* Overlay when YES is clicked */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:9999;
    }
    .overlayContent{
      width:min(520px, 92vw);
      background:#fff;
      border-radius:18px;
      padding:18px;
      text-align:center;
      box-shadow:0 18px 50px rgba(0,0,0,0.25);
    }
    .overlayContent h2{
      margin:8px 0 12px;
      color:#b1004b;
      font-size:24px;
    }
    .gif{
      width:100%;
      max-width:420px;
      border-radius:14px;
      display:block;
      margin:0 auto 14px;
    }
    .closeBtn{
      border:0;
      background:#ff2d6d;
      color:#fff;
      padding:10px 16px;
      border-radius:999px;
      cursor:pointer;
    }

    /* Heart confetti */
    .confetti-layer{
      pointer-events:none;
      position:fixed;
      inset:0;
      overflow:hidden;
      z-index:9998; /* under overlay */
    }
    .heart{
      position:absolute;
      opacity:0.95;
      animation: fall 2600ms ease-in forwards;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.15));
      will-change: transform, opacity;
    }
    @keyframes fall{
      0%   { transform: translateY(-25px) rotate(0deg) scale(0.9); opacity:0; }
      12%  { opacity:1; }
      100% { transform: translateY(110vh) rotate(280deg) scale(1.1); opacity:0; }
    }

    /* Angry emoji popup (center -> fade away) */
    .angry{
      position:fixed;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%) scale(0.6);
      opacity:0;
      font-size:64px;
      z-index:10000;
      pointer-events:none;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.25));
      animation: angryPop 1200ms ease-out forwards;
    }
    @keyframes angryPop{
      0%   { opacity:0; transform: translate(-50%, -50%) scale(0.5); }
      18%  { opacity:1; transform: translate(-50%, -50%) scale(1.05); }
      45%  { opacity:1; transform: translate(-50%, -50%) scale(1.0); }
      100% { opacity:0; transform: translate(-50%, -50%) scale(0.92); }
    }
  </style>
</head>

<body>
  <div class="card" id="card">
    <h1>Hey Aiza, Would you be my valentine? ğŸ’˜</h1>

    <div class="buttonsRow">
      <button id="yesBtn" aria-label="Yes">Yes</button>
      <!-- NO is visually positioned via JS as fixed; this placeholder keeps layout consistent -->
      <span style="width:1px;"></span>
    </div>
  </div>

  <!-- The actual NO button (fixed) -->
  <button id="noBtn" aria-label="No">No</button>

  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-label="Celebration">
    <div class="overlayContent">
      <h2>YAY!! ğŸ‰ğŸ’–</h2>
      <img
        class="gif"
        alt="Celebration"
        src="https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif"
      />
      <button class="closeBtn" id="closeBtn">Close</button>
    </div>
  </div>

  <script>
    const card = document.getElementById("card");
    const noBtn = document.getElementById("noBtn");
    const yesBtn = document.getElementById("yesBtn");
    const overlay = document.getElementById("overlay");
    const closeBtn = document.getElementById("closeBtn");

    // Confetti layer
    const confettiLayer = document.createElement("div");
    confettiLayer.className = "confetti-layer";
    document.body.appendChild(confettiLayer);

    // ---------------------------
    // NO: buttery, faster, bigger roam zone (2x the card size)
    // Also: cursor canâ€™t touch it.
    // ---------------------------
    let noPos = { x: -9999, y: -9999 }; // translate coords in viewport px
    let vx = 0, vy = 0;

    // Movement tuning
    const SAFE_RADIUS = 140;          // when cursor gets this close, it flees
    const STEP_PX = 150;              // speed/impulse (increased)
    const JITTER_PX = 32;
    const DAMPING = 0.18;             // lower = quicker response but still smooth
    const UPDATE_MS = 60;             // responsive without looking jittery
    const VIEWPORT_PADDING = 10;      // never clip off-screen

    // YES grows with each "escape"
    let dodgeCount = 0;
    const YES_GROWTH_PER = 0.07;
    const YES_MAX_SCALE = 2.4;

    // Chase detection for angry emoji
    const CHASE_RADIUS = 165;         // if you keep the cursor near for long, show ğŸ˜¡
    const CHASE_MS = 3000;
    let chaseStart = null;
    let angryCooldownUntil = 0;

    let lastUpdate = 0;
    let lastDodgedAt = 0;

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function cardRoamRect2x() {
      const r = card.getBoundingClientRect();
      const cx = r.left + r.width / 2;
      const cy = r.top + r.height / 2;
      const w = r.width * 2;
      const h = r.height * 2;
      return {
        left: cx - w / 2,
        right: cx + w / 2,
        top: cy - h / 2,
        bottom: cy + h / 2
      };
    }

    function placeNoInitially() {
      // Start near where a "No" would be in the row, but as fixed.
      const r = card.getBoundingClientRect();
      const x = r.left + r.width / 2 + 70;  // slightly right of center
      const y = r.top + r.height - 58;      // near bottom inside the card
      setNoPos(x, y, true);
    }

    function setNoPos(x, y, immediate = false) {
      noPos.x = x;
      noPos.y = y;

      // If immediate, temporarily remove transition to avoid first â€œjumpâ€
      if (immediate) {
        const prev = noBtn.style.transition;
        noBtn.style.transition = "none";
        noBtn.style.transform = `translate(${x}px, ${y}px)`;
        // force reflow then restore transition
        void noBtn.offsetHeight;
        noBtn.style.transition = prev || "transform 800ms cubic-bezier(.16,1,.3,1)";
      } else {
        noBtn.style.transform = `translate(${x}px, ${y}px)`;
      }
    }

    function distanceToButton(mouseX, mouseY) {
      const rect = noBtn.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const dx = cx - mouseX;
      const dy = cy - mouseY;
      return { dx, dy, dist: Math.hypot(dx, dy), cx, cy };
    }

    function growYes() {
      dodgeCount += 1;
      const s = clamp(1 + dodgeCount * YES_GROWTH_PER, 1, YES_MAX_SCALE);
      yesBtn.style.transform = `scale(${s})`;
    }

    function showAngry() {
      const el = document.createElement("div");
      el.className = "angry";
      el.textContent = "ğŸ˜¡";
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1300);
    }

    function updateNo(mouseX, mouseY) {
      const now = Date.now();
      if (now - lastUpdate < UPDATE_MS) return;
      lastUpdate = now;

      const { dx, dy, dist } = distanceToButton(mouseX, mouseY);

      // Chase timer logic
      if (dist < CHASE_RADIUS) {
        if (chaseStart === null) chaseStart = now;
        if (now - chaseStart >= CHASE_MS && now >= angryCooldownUntil) {
          showAngry();
          angryCooldownUntil = now + 3500; // cooldown so it doesnâ€™t spam
          chaseStart = null;              // reset
        }
      } else {
        chaseStart = null;
      }

      // If not close enough, do nothing
      if (dist > SAFE_RADIUS) return;

      // Count an escape (but not too frequently)
      if (now - lastDodgedAt > 420) {
        growYes();
        lastDodgedAt = now;
      }

      // Direction away from cursor
      const len = dist || 1;
      const ux = dx / len;
      const uy = dy / len;

      // Stronger push if closer
      const strength = clamp((SAFE_RADIUS - dist) / SAFE_RADIUS, 0.2, 1);

      // â€œButteryâ€ acceleration to velocity
      const ax = ux * STEP_PX * strength + (Math.random() * 2 - 1) * JITTER_PX;
      const ay = uy * (STEP_PX * 0.7) * strength + (Math.random() * 2 - 1) * (JITTER_PX * 0.75) - 18;

      vx = vx * (1 - DAMPING) + ax * DAMPING;
      vy = vy * (1 - DAMPING) + ay * DAMPING;

      // Proposed new position
      let nx = noPos.x + vx;
      let ny = noPos.y + vy;

      // Clamp inside: roam zone = 2x card, but also inside viewport so it never disappears
      const roam = cardRoamRect2x();
      const btnRect = noBtn.getBoundingClientRect();
      const bw = btnRect.width;
      const bh = btnRect.height;

      const minX = Math.max(roam.left, VIEWPORT_PADDING);
      const maxX = Math.min(roam.right - bw, window.innerWidth - bw - VIEWPORT_PADDING);
      const minY = Math.max(roam.top, VIEWPORT_PADDING);
      const maxY = Math.min(roam.bottom - bh, window.innerHeight - bh - VIEWPORT_PADDING);

      // If card is near edges, bounds can collapse; protect against that
      nx = clamp(nx, minX, maxX);
      ny = clamp(ny, minY, maxY);

      setNoPos(nx, ny);
    }

    // Track mouse and keep NO untouchable
    document.addEventListener("mousemove", (e) => {
      updateNo(e.clientX, e.clientY);
    });

    // Also react if mouse enters NO (just in case)
    noBtn.addEventListener("mouseenter", (e) => {
      updateNo(e.clientX, e.clientY);
    });

    // Place NO once layout is ready
    window.addEventListener("load", () => {
      placeNoInitially();
    });

    window.addEventListener("resize", () => {
      // Reset to a sensible position on resize
      dodgeCount = 0;
      yesBtn.style.transform = "scale(1)";
      vx = 0; vy = 0;
      placeNoInitially();
    });

    // ---------------------------
    // Hearts on YES + overlay
    // ---------------------------
    function burstHearts(count = 110) {
      const hearts = ["ğŸ’–", "ğŸ’˜", "ğŸ’—", "ğŸ’“", "ğŸ’•", "â¤ï¸"];
      for (let i = 0; i < count; i++) {
        const el = document.createElement("div");
        el.className = "heart";
        el.textContent = hearts[Math.floor(Math.random() * hearts.length)];

        const x = Math.random() * 100;
        const size = 14 + Math.random() * 22;
        const dur = 2000 + Math.random() * 1600;
        const delay = Math.random() * 160;

        el.style.left = x + "vw";
        el.style.top = (-10 - Math.random() * 20) + "vh";
        el.style.fontSize = size + "px";
        el.style.animationDuration = dur + "ms";
        el.style.animationDelay = delay + "ms";

        confettiLayer.appendChild(el);
        setTimeout(() => el.remove(), dur + delay + 600);
      }
    }

    yesBtn.addEventListener("click", () => {
      burstHearts(120);
      overlay.style.display = "flex";
    });

    function closeOverlay(){ overlay.style.display = "none"; }

    closeBtn.addEventListener("click", closeOverlay);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeOverlay(); });
    document.addEventListener("keydown", (e) => { if (e.key === "Escape") closeOverlay(); });
  </script>
</body>
</html>
